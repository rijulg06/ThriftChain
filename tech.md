Decentralized Marketplace Architecture Guide (Sui + Next.js)

For a decentralized marketplace on Sui, you want to maximize the use of the blockchain for ownership and state while utilizing decentralized file storage for media assets.

1. Storing Marketplace Listings (The Data & Tags)

Core Principle: The listing data (including tags) is stored on-chain in your Move Item Object.

The Sui Native Solution: Kiosk Objects

The official and most robust way to build a marketplace on Sui is by leveraging the Sui Kiosk standard.

| Element | Storage Location | Why |
| Listing Status/Price | Sui Kiosk Object (On-Chain) | Guarantees that the listing is secure, non-custodial, and verifiable. |
| Name, Description | Sui Object Fields (On-Chain) | Standard metadata for the item. |
| Generated Tags | Sui Object Fields (Vec<String> on-Chain) | Store tags generated by Gemini API as a vector of strings in the item's metadata. |
| Ownership | Sui Object Fields (On-Chain) | The seller's wallet address owns the KioskOwnerCap and the associated item object. |

How it works:

Your Next.js app uses the Gemini API (via a serverless function) to generate a list of tags from the user's uploaded image.

The user submits a transaction that creates the item object, including this list of tags.

This list of tags is stored as a Vec<String> in your custom Move struct.

2. Storing Product Photos (Walrus & Multiple Assets)

You are locking in Walrus as your decentralized storage solution, which is excellent for the Sui ecosystem.

The Walrus & Multiple Image Solution

Since Walrus returns a unique Content ID (Blob ID) for each file, your item object must store an array of these IDs.

| Element | Storage Location | Why |
| Image File (JPEG/PNG) | Walrus Decentralized Storage | Scalable, cost-effective, and Sui-native asset storage. |
| Image URL Links | Sui Object Fields (Vec<String> on-Chain) | The item object will store a list of Walrus Blob IDs (or public URLs pointing to Walrus data) in a custom Move field, enabling multiple images per listing. |

3. User Authentication

The goal is to support both crypto-native and Web2 users. This requires a dual authentication strategy.

CRITICAL FLOW: Browsing (/ and /listings and /listing/[id]) is public. Login is only required for transactions (/list-item, "Buy Now" button click) and dashboard access.

Authentication Strategy: Wallet Kit vs. zkLogin

| Method | User Type | Identity Source | Purpose |
| 1. Wallet Kit | Crypto-native (advanced) | Sui Wallet, Ethos Wallet, etc. | High-security, key management is user's responsibility. |
| 2. zkLogin (OAuth) | Web2-native (novice) | Google, Facebook, Twitch, etc. | Simplified, seed phrase-less onboarding using familiar social logins. |

The Web3 Native Solution: Wallet Kit

The standard approach for Sui/Next.js applications is to use the Suiet Wallet Kit.

| Element | Tool | Purpose |
| Wallet Connection | @suiet/wallet-kit | Handles connecting to Sui-compatible wallets in your Next.js app. |
| API/Client | @mysten/sui | Used to build and send PTBs to the Sui network. |
| User ID | wallet.account.address | The user's public key acts as their unique, global ID. |

The OAuth Solution: zkLogin

zkLogin is a Sui primitive that generates a unique Sui address for a user based on their OAuth login (like Google). It uses Zero-Knowledge Proofs (ZKP) to prove ownership of the login credential without revealing sensitive personal data on-chain.

How zkLogin works with OAuth:

OAuth Flow: Your dApp directs the user to Google/Facebook. The OAuth provider returns a JSON Web Token (JWT).

Ephemeral Key: The user's wallet (which can be an invisible wallet implementation) creates a short-lived, ephemeral key pair.

Proof Generation: The JWT, the ephemeral key, and a unique salt (used for privacy) are used to generate a ZKP.

Transaction Signing: The user's transaction is signed with the ephemeral key and submitted along with the ZKP. Sui Validators verify the ZKP against the on-chain metadata to confirm the transaction's validity.

Address Derivation: The final Sui address is derived from the OAuth ID (sub), the provider (iss), and the unique salt.

For your Next.js App: You will use the @mysten/sui/zklogin tools and potentially a community SDK or a managed service like Enoki or Shinami to handle the complex ZKP generation and salt management.

4. Vector-Powered Querying (The Off-Chain Indexer)

To enable "similar object but not an exact match" search, you need to calculate a vector embedding for each item's tags and store it in a specialized vector database (VDb).

The Indexing Architecture (Supabase with pgvector)

You will use Supabase for your central database needs, leveraging the pgvector extension for similarity search.

| Component | Supabase Element | Purpose |
| Vector DB | pgvector Extension | Enables the storage of vector embeddings in a PostgreSQL column. |
| History DB | items_sold Table | Stores unchangeable transaction history (/dashboard/sold). |
| Vector Index Table | marketplace_vectors Table | Stores the Sui Object ID, concatenated tags/description, and the semantic vector. |
| Search Logic | PostgreSQL RPC Function | A secure function (rpc call) that takes a query vector and executes the cosine similarity search. |

Required Supabase SQL Setup (To be run in Supabase SQL Editor):

-- 1. Enable the pgvector extension
CREATE EXTENSION IF NOT EXISTS vector;

-- 2. Create the Vector Index Table
CREATE TABLE marketplace_vectors (
    sui_object_id TEXT PRIMARY KEY,
    -- Concatenated searchable text (tags + description)
    content TEXT,
    -- Vector embedding (use the dimension size provided by your embedding model, e.g., 1536)
    embedding vector(1536)
);

-- 3. Create the Search Function (for similarity search via Next.js API)
CREATE OR REPLACE FUNCTION match_listings (
    query_embedding vector(1536),
    match_threshold float,
    match_count int
)
RETURNS TABLE (
    sui_object_id TEXT,
    content TEXT,
    similarity float
)
LANGUAGE sql STABLE
AS $$
    SELECT
        sui_object_id,
        content,
        1 - (marketplace_vectors.embedding <=> query_embedding) AS similarity
    FROM marketplace_vectors
    WHERE 1 - (marketplace_vectors.embedding <=> query_embedding) > match_threshold
    ORDER BY similarity DESC
    LIMIT match_count;
$$;


The Frontend Vector Search Flow

When a user searches on /listings:

Frontend sends the user's query to your Next.js /api/search/similarity-search handler.

The Route Handler generates the vector embedding from the query (using Gemini or another model).

The Route Handler calls the Supabase client's rpc('match_listings', ...) method.

Supabase returns a list of matching Sui Object IDs (from the marketplace_vectors table).

The Frontend uses these Object IDs to call the Sui RPC's multiGetObjects to fetch the complete, authenticated listing data.

5. Next.js Application Structure Roadmap (App Router)

A. Next.js Route Handlers (Backend: /app/api/*/route.ts)

These routes handle the secure, server-side logic (e.g., Gemini API, Walrus upload, zkLogin) and indexing/search.

Route Path

File Location

Method

Purpose

Reference in Architecture

/api/gemini/generate-tags

/app/api/gemini/generate-tags/route.ts

POST

Calls Gemini API to analyze image/description and return descriptive tags.

Section 1 & 5

/api/walrus/upload-blob

/app/api/walrus/upload-blob/route.ts

POST

Handles file upload to Walrus and returns the Blob ID(s).

Section 2

/api/search/similarity-search

/app/api/search/similarity-search/route.ts

POST

Primary search endpoint. Calls Supabase RPC match_listings to query VDb indexer for relevant Sui Object IDs based on a semantic query.

Section 4

/api/zklogin/start-flow

/app/api/zklogin/start-flow/route.ts

GET

Initiates zkLogin. Generates the unique nonce and constructs the OAuth URL for user redirection.

Section 3

/api/indexer/listen-event

/app/api/indexer/listen-event/route.ts

POST

(Internal/Webhook) Endpoint used by your off-chain Indexing Service to process blockchain events (e.g., ItemListed). Inserts vector into Supabase.

Section 4

Critical Note on Action Routes: There are no dedicated /api/list-item, /api/buy, or /api/delist routes. In a dApp, these actions must be client-side functions that construct a Sui Programmable Transaction Block (PTB) and prompt the user's connected wallet (Wallet Kit or zkLogin) to sign and submit it directly to the Sui network. The server cannot sign transactions on the user's behalf.

B. Next.js Frontend Pages (Client: /app/*)

These are the primary UI components that handle user interaction and wallet integration.

Page Path

File Location

Core Functions

Interaction Type

Aesthetic Goal

/

/app/page.tsx

Landing Page only. Displays a hero section, the main search bar, and CTA buttons (Login, List Item). Search input navigates to /listings?q=....

Landing Focused (Engagement): High-impact hero section with a central, prominent search bar. No listings displayedâ€”its goal is to drive the user to the /listings page or to authenticate.



/listings

/app/listings/page.tsx

Displays all marketplace listings (via /api/search/similarity-search using searchParams.get('q')). Includes secondary filters and the responsive item card grid.

Discovery Focused (Browsing): Responsive grid layout for item cards (image, name, price). Designed for continuous scrolling, dynamic filtering, and showcasing many results.



/listing/[id]

/app/listing/[id]/page.tsx

Displays item details, images, tags, and the Buy Now button. (Uses the dynamic route segment [id]). The "Buy Now" button must initiate the wallet connection/zkLogin process if the user is not authenticated.

Read & Write (Buy)

Conversion Focused (Trust & Detail): Detailed, multi-column layout (e.g., 60/40 split). Left for the Walrus image carousel. Right for the price, full description, generated tags, and the large, brightly colored "Buy Now" component. Goal: Provide all necessary information before the transaction.

/list-item

/app/list-item/page.tsx

The Seller Form. Handles image upload, calls /api/gemini/generate-tags, builds the PTB (Move Call for list_item), and prompts the user to sign the transaction.

Write (Sign Transaction)

Seller onboarding and form input.

/dashboard

/app/dashboard/page.tsx

Overview page for all owned assets. Redirects to /dashboard/listings or /dashboard/owned.

Read

Dashboard Navigation Hub.

/dashboard/listings

/app/dashboard/listings/page.tsx

Queries user's Kiosk Object for all items currently listed for sale. Allows the seller to Delist an item (Move transaction using delist_item).

Read (Kiosk) & Write (Delist)

Management Interface: Table view of active items, price, listing date, and a "Delist" button. Use badges to highlight if an item has a pending offer.

/dashboard/sold

/app/dashboard/sold/page.tsx

Queries the off-chain Indexer/Database for a history of ItemSold events where the connected user was the seller.

Read (Indexer)

Transaction History: List of closed sales, final price, date, and buyer's Sui address. Includes a "Transaction Link" to the Sui Explorer. Highlight the most recent sale clearly.

/auth/callback

/app/auth/callback/page.tsx

zkLogin Redirect Target. Receives the OAuth JWT, verifies it, manages ephemeral key and salt, and establishes the local zkLogin session.

Auth & Client Logic

Handles redirection/loading screen only.

6. Move Contract Structure (The Core of the Marketplace)

Your Move package (e.g., marketplace_module) will manage the item asset and interact directly with the official sui::kiosk module.

A. Core Structs (Objects)

Struct Name

Abilities

Purpose

Item

key, store, drop

Your unique digital asset struct (NFT). It holds the Walrus Blob IDs and Gemini tags. Must be wrapped by sui::kiosk to be listed.

MarketplaceAdminCap

key

A singleton capability object used to prove authority to create initial market structures (like TransferPolicy).

module my_package::marketplace_module {
    use sui::object::UID;
    use sui::kiosk::{Self, Kiosk}; // Import Kiosk for listing/buying

    public struct Item has key, store, drop {
        id: UID,
        // List of Walrus CIDs/URLs
        image_urls: vector<String>, 
        // Tags generated by Gemini/Vector Indexer
        tags: vector<String>,       
        // Example: The item's primary asset ID
        asset_id: u64,
    }
    // ... other structs
}


B. Transaction Entry Functions

These functions will be called by the user's wallet via a Programmable Transaction Block (PTB).

Action

Move Function (Entry Point)

Sui Kiosk Call

List Item

list_item

Calls kiosk::list to move the Item into the Kiosk and set the price.

Buy Item

buy_item

Calls kiosk::purchase to transfer the Item out and the payment coin to the seller.

Delist Item

delist_item

Calls kiosk::delist to remove the item from the market and place it back into the seller's wallet.

Create Kiosk

create_kiosk_for_user

Calls kiosk::default to create a new shared Kiosk object and transfer the KioskOwnerCap to the user's address. (Often called on first login/listing attempt).

Example Function Signatures (Concept):

// 1. LIST ITEM (The core of the seller's action)
public entry fun list_item<T: key + store>(
    item: T, 
    price: u64,
    kiosk: &mut Kiosk,
    kiosk_owner_cap: &KioskOwnerCap,
    ctx: &mut TxContext
) {
    // Uses the Kiosk standard function to list the item
    kiosk::list(item, price, kiosk, kiosk_owner_cap, ctx);
    // Emit ItemListed event here
}

// 2. DELIST ITEM (The action to remove items from /dashboard/listings)
public entry fun delist_item<T: key + store>(
    item_id: ID,
    kiosk: &mut Kiosk,
    kiosk_owner_cap: &KioskOwnerCap,
    ctx: &mut TxContext
) {
    // Calls the Kiosk function to delist and returns the item to the sender's address
    let item: T = kiosk::delist(item_id, kiosk, kiosk_owner_cap, ctx);
    transfer::public_transfer(item, tx_context::sender(ctx));
    // Emit ItemDelisted event here
}

// 3. BUY ITEM (The action from /listing/[id])
public entry fun buy_item<T: key + store, C>(
    item_id: ID,
    payment_coin: Coin<C>,
    kiosk: &mut Kiosk,
    ctx: &mut TxContext
) {
    // Calls Kiosk function to purchase and handle coin/item transfer
    let item: T = kiosk::purchase(item_id, payment_coin, kiosk, ctx);
    transfer::public_transfer(item, tx_context::sender(ctx));
    // Emit ItemSold event here
}


C. Events (For the Off-Chain Indexer)

Your Move contract must emit events so your Supabase Indexer knows when to update its data.

Event Name

Triggered By

Indexer Action

ItemListedEvent

list_item

Generates vector embedding (via Gemini/API) and Inserts a new record into the marketplace_vectors table.

ItemSoldEvent

buy_item

Deletes the record from the marketplace_vectors table (item no longer for sale) and Inserts a record into the items_sold history table.

ItemDelistedEvent

delist_item

Deletes the record from the marketplace_vectors table (item no longer for sale).